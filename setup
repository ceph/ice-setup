#!/usr/bin/env python

# Copyright 2013, Inktank Storage, Inc.
# All rights reserved.
#
# This software and related documentation are provided under a license
# agreement containing restrictions on use and disclosure and are protected by
# intellectual property laws.  Except as expressly permitted in your license
# agreement or allowed by law, you may not use, copy, reproduce, translate,
# broadcast, modify, license, transmit, distribute, exhibit, perform, publish,
# or display any part, in any form, or by any means.  Reverse engineering,
# disassembly, or decompilation of this software, unless required by law for
# interoperability, is prohibited.
#
# The information contained herein is subject to change without notice and is
# not warranted to be error-free.  If you find any errors, please report them
# to us in writing.
#
# This software or hardware is developed for general use in a variety of
# information management applications.  It is not developed or intended for use
# in any inherently dangerous applications, including applications which may
# create a risk of personal injury.  If you use this software or hardware in
# dangerous applications, then you shall be responsible to take all appropriate
# fail-safe, backup, redundancy, and other measures to ensure its safe use.
# Inktank Storage, Inc.  and its affiliates disclaim any liability for any
# damages caused by use of this software or hardware in dangerous applications.

import logging
import platform
import subprocess
import sys


# =============================================================================
# Logging
# =============================================================================

logger = logging.getLogger('ice')

BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE = range(8)

COLORS = {
    'WARNING': YELLOW,
    'INFO': WHITE,
    'DEBUG': BLUE,
    'CRITICAL': RED,
    'ERROR': RED
}

RESET_SEQ = "\033[0m"
COLOR_SEQ = "\033[1;%dm"
BOLD_SEQ = "\033[1m"

BASE_COLOR_FORMAT = "%(color_levelname)s %(message)s"
VERBOSE_COLOR_FORMAT = "[%(name)s][$BOLD%(levelname)s] $RESET%(color_levelname)s %(message)s"


def color_message(message):
    message = message.replace("$RESET", RESET_SEQ).replace("$BOLD", BOLD_SEQ)
    return message


class ColoredFormatter(logging.Formatter):
    """
    A very basic logging formatter that not only applies color to the levels of
    the ouput but will also truncate the level names so that they do not alter
    the visuals of logging when presented on the terminal.
    """

    def __init__(self, msg):
        logging.Formatter.__init__(self, msg)

    def format(self, record):
        levelname = record.levelname
        truncated_level = record.levelname[:6]
        if levelname in COLORS:
            levelname_color = COLOR_SEQ % (30 + COLORS[levelname]) + '-->' + RESET_SEQ
            record.color_levelname = levelname_color
        return logging.Formatter.format(self, record)


def color_format(verbose=False):
    """
    Main entry point to get a colored formatter, it will use the
    BASE_FORMAT by default.
    """
    if verbose:
        color_format = color_message(VERBOSE_COLOR_FORMAT)
    else:
        color_format = color_message(BASE_COLOR_FORMAT)
    return ColoredFormatter(color_format)


# =============================================================================
# Exceptions
# =============================================================================

class ICEError(Exception):
    """Base ICE Setup exception"""
    pass


class NonZeroExit(ICEError):
    """subprocess commands that exit with non-zero status"""


# =============================================================================
# Subprocess
# =============================================================================


def run(cmd, logger, **kw):
    stop_on_nonzero = kw.pop('stop_on_nonzero', True)

    process = subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        close_fds=True,
        **kw
    )

    if process.stderr:
        while True:
            err = process.stderr.readline()
            if err == '' and process.poll() is not None:
                break
            if err != '':
                logger.warning(err)
                sys.stderr.flush()
    if process.stdout:
        while True:
            out = process.stdout.readline()
            if out == '' and process.poll() is not None:
                break
            if out != '':
                logger.debug(out)
                sys.stdout.flush()

    returncode = process.wait()
    if returncode != 0:
        error_msg = "command returned non-zero exit status: %s" % returncode
        if stop_on_nonzero:
            raise NonZeroExit(error_msg)
        else:
            logger.warning(error_msg)


def run_call(cmd, logger=None, **kw):
    """
    a callable that will execute a subprocess without raising an exception if
    the exit status is non-zero.

    The ``logger`` argument is in the signature only for consistency in the
    API, it does nothing by default.
    """

    process = subprocess.Popen(
        cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, **kw
    )
    stdout = [line.strip('\n') for line in process.stdout.readlines()]
    stderr = [line.strip('\n') for line in process.stderr.readlines()]
    return stdout, stderr, process.wait()


# =============================================================================
# System
# =============================================================================

def platform_information():
    """
    detect platform information, return a dictionary with the following keys:

    * distro_name: as in 'Ubuntu' or 'CentOS'
    * release:     like '5.0' or '13.04'
    * codename:    as in 'Wheezy' or 'Quantal'
    """
    distro, release, codename = platform.linux_distribution()

    # this could be an empty string in Debian
    if not codename and 'debian' in distro.lower():
        debian_codenames = {
            '8': 'jessie',
            '7': 'wheezy',
            '6': 'squeeze',
        }
        major_version = release.split('.')[0]
        codename = debian_codenames.get(major_version, '')
    return dict(
        distro_name=_normalized_distro_name(distro.rstrip()),
        release=release.rstrip(),
        codename=codename.rstrip(),
    )


def _normalized_distro_name(distro):
    """
    Normalizes the distribution name so it is easier to operate on well knowns
    rather than whatever small differences distributions decide to add to them
    """
    distro = distro.lower()
    if distro.startswith(('redhat', 'red hat')):
        return 'redhat'
    elif distro.startswith(('scientific', 'scientific linux')):
        return 'scientific'
    elif distro.startswith(('suse', 'opensuse')):
        return 'suse'
    return distro


# =============================================================================
# File Utilities
# =============================================================================

def extract_file(file_path):
    """
    Decompress/Extract a tar file to a temporary location and return its full
    path so that it can be handled elsewhere.  If ``file_path`` is not a tar
    file and it is a directory holding decompressed files return ``file_path``,
    otherwise raise an error.
    """
    pass


def overwrite_dir(source, destination):
    """
    Copy all files from _source_ to a temporary location (if not in a temporary
    location already) and then overwrite the contents of its destination so
    that the contents are as up to date as possible
    """
    # TODO: Need to define the destination of respository files, for example:
    # /opt/ceph-repos
    pass


def default_repo_location():
    """
    Calculates the default repository location of the repository files, for
    example if this script runs alongside the sources it would get the absolute
    path for the ``sources`` directory relative to this script.
    """
    # TODO: Needs to know about the location (and names) of directories
    # packaged alongside this script
    pass

# =============================================================================
# Prompts
# =============================================================================


def prompt(question, _raw_input=None):
    input_prompt = _raw_input or raw_input
    prefix = '%s-->%s ' % (COLOR_SEQ % (30 + COLORS['DEBUG']), RESET_SEQ)
    prompt_format = '{prefix} {question}'.format(prefix=prefix, question=question)
    response = input_prompt(prompt_format)
    try:
        return strtobool(response)
    except ValueError:
        logger.error('That response was invalid, please try again')
        return prompt(question, _raw_input=input_prompt)


def strtobool(val):
    """
    Convert a string representation of truth to true (1) or false (0).

    True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values are
    'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if 'val' is
    anything else.

    .. note:: lifted from distutils.utils.strtobool
    """
    try:
        val = val.lower()
    except AttributeError:
        val = str(val).lower()
    if val in ('y', 'yes', 't', 'true', 'on', '1', '', None):
        return 1
    elif val in ('n', 'no', 'f', 'false', 'off', '0'):
        return 0
    else:
        raise ValueError("invalid input value: %r" % (val,))


# =============================================================================
# Main
# =============================================================================


def main(argv=None):
    argv = argv or sys.argv
    # Console Logger
    terminal_log = logging.StreamHandler()
    terminal_log.setFormatter(color_format(verbose='-v' in argv))
    logger.addHandler(terminal_log)
    logger.setLevel(logging.DEBUG)


if __name__ == '__main__':
    sys.exit(main())
